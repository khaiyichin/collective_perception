include "body_common.bzz"

function init()
{
    # Initialize values
    reset_values()

    # Define listener callback function
    neighbors.listen("local_vals",
        function(vid, neighbor_local_val_table, rid) # each neighbor_local_val_table consists of x and conf
        {
            curr_neighbor_vals = append_to_table(curr_neighbor_vals, neighbor_local_val_table)
        }
    )
    
    ### Set custom seed that depends on the clock ###
    # This has to be done so that not all the robots are set to the same clock seed:
    #   * Default seed (i.e., clock) causes all the robots to be seeded the same, making them behave the same
    #   * Vanilla ID custom seed (i.e., `math.rng.setseed(id)`) causes deterministic behaviors across different trials
    # Solution: `math.rng.uniform()` is seeded by the clock, while `id` modifies the seed for the number generator used in the motion
    # Robots now all behave differently, across different trials.
    math.rng.setseed(id + math.rng.uniform())
}

function step()
{
    # Detect any nearby obstacles
    var obstacles = detect_obstacles()
    if (not obstacles)
    {
        # Move robot in random walk fashion
        if (not motion_disabled)
        {
            var movement = move(move_type, move_duration, rot_direction, spd)
            move_type = movement.type
            move_duration = movement.duration
            rot_direction = movement.rot_dir
        }
        else
        {
            gotop(0.0, 0.0) # stop robot
            move_status = 0 # not moving
        }

        # Make observation
        if (not sense_disabled)
        {
            observe()
        }
        else
        {
            sense_status = 0 # not sensing
        }
    }
    else
    {
        # Avoid obstacles
        if (not motion_disabled)
        {
            var movement = avoid_obstacles(spd, obstacles)
            move_type = movement.type
            move_duration = movement.duration
            rot_direction = movement.rot_dir
        }
        else
        {
            gotop(0.0, 0.0) # stop robot
            move_status = 0
        }
    }

    # Communicate
    if (not comms_disabled)
    {
        # Broadcast values
        communicate_tx("local_vals", local_vals)

        # Update values
        var neighbor_vals = {.past = past_neighbor_vals, .curr = curr_neighbor_vals}

        neighbor_vals = update_received_messages(neighbor_vals)

        # Update values
        past_neighbor_vals = neighbor_vals.past
        curr_neighbor_vals = neighbor_vals.curr
    }
    else
    {
        # Kill listener callback function
        neighbors.ignore("local_vals")
        comms_status = 0 # not communicating
    }
}

# Executed once when the robot (or the simulator) is reset.
function reset()
{
    reset_values()
}
 
# Executed once at the end of experiment.
function destroy() {}

##############################
### User defined functions ###
##############################

# Clear the robot values
function reset_values()
{
    # Define sensor accuracy variables, modified by the ARGoS loop functions
    b_prob = nil
    w_prob = nil

    # Define velocity variables, modified by the ARGoS loop functions
    spd = nil # cm/s

    # Define initial values, not modified by ARGoS loop functions
    local_vals = {.x = 0.5, .conf = 0.0}

    total_b_tiles_obs = 0
    total_obs = 0

    past_neighbor_vals = {}
    curr_neighbor_vals = {}

    move_type = nil
    move_duration = 0
    rot_direction = nil

    debug_data = {.encounter = 0, .observation = 0} # stored for debugging; not used in actual computation

    motion_disabled = 0
    comms_disabled = 0
    sense_disabled = 0

    move_status = 1
    comms_status = 1
    sense_status = 1
}

# Execute observation
function observe()
{
    # * The ground sensors are located on the bottom of the robot, and can
    # * be used to perform line following.
    # *
    # * The readings are in the following order (seeing the robot from TOP,
    # * battery socket is the BACK):
    # *
    # *      front
    # *
    # *      0   3    r
    # * l             i
    # * e  1       2  g
    # * f             h
    # * t             t
    # *
    # *       back
    # *

    ######################################################################################
    ##### The following snippet is commented out (for now?) due to the size of tile used
    ##### (1cm, constrained by movement speed)

    # # Use both front sensors (0 and 3) to only record observation if they match
    # # This is acceptable for now since the distance between them is < 3cm.
    # # See http://ftp.k-team.com/KheperaIV/software/Gumstix%20COM%20Y/UserManual/Khepera%20IV%20User%20Manual%204.x.pdf

    # # The 'ground' keyword is a table provided to query the ground sensor readings

    # # Check if both sensors see the same color (only using front sensors, not side)
    # var left_front_color = ground[0].value
    # var right_front_color = ground[3].value

    # if (left_front_color == right_front_color)
    # {
    #     # Make observation using artificial noise (probability)
    #     # The actual sensor is set to have no noise
    #     var encounter = int(left_front_color)
    #     var prob = 0.0

    #     if (encounter == 1) # white
    #     {
    #         prob = w_prob
    #     }
    #     else if (encounter == 0) # black
    #     {
    #         prob = b_prob
    #     }
    #     else
    #     {
    #         return nil # invalid observation
    #     }

    #     var noisy_observation = int(1-observe_noisy(encounter, prob)) # this is because black and white are flipped

    #     debug_data["encounter"] = encounter
    #     debug_data["observation"] = noisy_observation

    #     total_b_tiles_obs = total_b_tiles_obs + noisy_observation
    #     total_obs = total_obs + 1
    # }
    # else
    # {
    #     return nil
    # }
    ######################################################################################


    # Use left sensor to detect ground value
    # See http://ftp.k-team.com/KheperaIV/software/Gumstix%20COM%20Y/UserManual/Khepera%20IV%20User%20Manual%204.x.pdf

    # The 'ground' keyword is a table provided to query the ground sensor readings
    var left_front_color = ground[0].value

    # Make observation using artificial noise (probability)
    # The actual sensor is set to have no noise
    var encounter = int(left_front_color)
    var prob = 0.0

    if (encounter == 1) # white
    {
        prob = w_prob
    }
    else if (encounter == 0) # black
    {
        prob = b_prob
    }
    else
    {
        logerr("Invalid encounter observed!")
        return nil # invalid observation
    }

    var noisy_observation = int(1-observe_noisy(encounter, prob)) # this is because black and white are flipped

    debug_data["encounter"] = 1-encounter # to maintain consistency
    debug_data["observation"] = noisy_observation

    total_b_tiles_obs = total_b_tiles_obs + noisy_observation
    total_obs = total_obs + 1
}

# Provide noisy observation
function observe_noisy(encounter, sensor_prob)
{
    if (math.rng.uniform(1.0) < sensor_prob)
    {
        return encounter
    }
    else
    {
        return int(1 - encounter)
    }
}